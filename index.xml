<?xml version='1.0' encoding='utf-8'?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc toc="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc symrefs="yes" ?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="info"
  ipr="trust200902" submissionType="IETF"
  docName="draft-multiformats-multibase-07"
  tocInclude="true" sortRefs="true" symRefs="true" version="2">

<front>
  <title>The Multibase Data Format</title>
  <seriesInfo name="Internet-Draft" value="draft-multiformats-multibase-07"/>
  <author initials="J." surname="Benet" fullname="Juan Benet">
    <organization>Protocol Labs</organization>
    <address>
      <postal>
        <street>548 Market Street, #51207</street>
        <city>San Francisco</city>
        <region>CA</region>
        <code>94104</code>
        <country>US</country>
      </postal>
      <phone>+1 619 957 7606</phone>
      <email>juan@protocol.ai</email>
      <uri>http://juan.benet.ai/</uri>
    </address>
  </author>

  <author initials="M." surname="Sporny" fullname="Manu Sporny">
    <organization>Digital Bazaar</organization>
    <address>
      <postal>
        <street>203 Roanoke Street W.</street>
        <city>Blacksburg</city>
        <region>VA</region>
        <code>24060</code>
        <country>US</country>
      </postal>
      <phone>+1 540 961 4469</phone>
      <email>msporny@digitalbazaar.com</email>
      <uri>http://manu.sporny.org/</uri>
    </address>
  </author>

  <author initials="J." surname="Caballero" fullname="Juan Caballero">
    <organization>learningProof uG</organization>
    <address>
      <postal>
        <street>Kiefholzstrasse</street>
        <city>Berlin</city>
        <region>Berlin</region>
        <code>12435</code>
        <country>Germany</country>
      </postal>
      <phone>+1 415 555 5555</phone>
      <email>bumblefudge@learningproof.xyz</email>
      <uri>http://learningproof.xyz/</uri>
    </address>
  </author>

  <date month="July" day="21" year="2023" />
  <area>Security</area>
  <workgroup />
  <keyword>base-encoding</keyword>
  <keyword>base64</keyword>
  <keyword>base58</keyword>
  <keyword>base32</keyword>
  <keyword>base16</keyword>
  <keyword>base2</keyword>

  <abstract>
    <t>
Raw binary data is often encoded using a mechanism that enables the data to be
included in human-readable text-based formats. This mechanism is often referred
to as "base-encoding the data". Base-encoding is often used when expressing
binary data in hyperlinks, cryptographic keys in web pages, or security tokens
in application software. There are a variety of base-encodings, such as base32,
base58, and base64. It is not always possible to differentiate one base-encoding
from another without knowing the context in which it was encoded. The purpose of
this specification is to provide a mechanism to be able to deterministically
identify the base-encoding for a particular string of encoded data from its
encoded form.
    </t>
  </abstract>

  <note title="Feedback">
    <t>
This specification is a joint work product of
<eref target="https://protocol.ai/">Protocol Labs</eref>,
and the
<eref target="https://w3c-ccg.github.io/">W3C Credentials Community Group</eref>.
Feedback related to this specification should logged in the
<eref target="https://github.com/w3c-ccg/multibase/issues">issue tracker</eref>
or be sent to
<eref target="mailto:public-credentials@w3.org">public-credentials@w3.org</eref>.
</t>
  </note>
</front>
<middle>
  <section anchor="intro" title="Introduction">
    <t>
This specification describes a forward-compatible data model for expressing
raw binary data in a variety of base-encoding formats such as base32,
base58. and base64.
    </t>
    <t>
When text is encoded as bytes, we can usually use a one-size-fits-all
encoding (UTF-8) because we're always encoding to the same set of 256 bytes.
When that doesn't work, usually for historical or performance reasons, we
can usually infer the encoding from the context.
    </t>
    <t>
However, when bytes are encoded as text (using a base encoding), the
choice of base encoding is often restricted by the context. Worse, these
restrictions can change based on where the data appears in the text. In
some cases, we can only use [a-z0-9]. In others, we can use a larger set
of characters but need a compact encoding. This has lead to a large set
of "base encodings", one for every use-case. Unlike when encoding text to
bytes, we can't just standardize around a single base encoding because
there is no optimal encoding for all cases.
    </t>
    <t>
Unfortunately, it's not always clear what base encoding was used, and the
encoded form can often be severed from its encoding context; that's where this
specification comes in. It answers the question:
    </t>
    <t>
Given binary data <var>d</var> encoded into text <var>s</var>, what base <var>b</var> was used to encode it?
    </t>
    <t>
To answer this question, a single code point is prepended to <var>s</var> at time of
encoding, which signals which <var>b</var> can be used to reconstruct
<var>d</var> in that new context.
    </t>
  </section>
  <section anchor="components" title="The Multibase Format">
    <t>
A multibase-encoded value follows a simple format:
      <figure>
        <artwork>base-encoding-codepoint base-encoded-data</artwork>
      </figure>
    </t>
    <t>
Each unique encoding algorithm is thus represented unambiguously by a single
codepoint that is always the first codepoint in the target encoding. In
ASCII/lower-base encodings, this usually corresponds to the "first byte" in the
binary data, since these encodings are entirely in the single-byte range; in
use-cases where UTF-8 can be assumed for all input data, the encoding can thus
be detected on the binary side from the first byte for these encodings, rather
than on the encoded string. To date, all entries have followed the convention of
using the highest codepoint in the encoding alphabet as their prefix, but this
is not a requirement of future entries.
    </t>
    <t>
Although the "prefix codepoint" is the determinant value here, the range of all
possible multibase entries is narrower than all possible codepoints for two
reasons. Firstly, there are reserved entries required for the functioning of the
system; for example, the identity/null codepoint, which is a pseudo-entry
necessary for the functioning of the system (signalling an entry in a dataset
that cannot be multibased and must be treated otherwise). Secondly, the UTF-8
form of each codepoint, which can be used in contexts where multiple
base-encodings are used but only encoded from UTF-8, cannot collide with other
entries in the registry group (multiformats) of which multibase is only one
registry. Note that all registries in the registry group are organized around a
unique entry of UTF-8 bytes.  See also <eref target="#mb-registry">The Multibase
Algorithm Registry</eref> for more context, and also the <eref
target="https://github.com/multiformats/unsigned-varint">unsigned varint
specification</eref> for an explanation of how these UTF-8 bytes are generally
expressed and handled by current implementations.
    </t>
    <t>
To date, only ASCII codepoints have reached "final" status and been supported by
current implementations, but higher-base encodings could reach maturity at a
future time, necessitating a distinction between the ASCII-only implementations
and extended-range implementations. Note that two such extended-range
implementations are currently in the registry, proquint and base256emoji.
    </t>
    <section anchor="fields" title="A Multibase Example">
      <t>
The following is an encoding of "Hello World!" in the version of base-58
that uses the Bitcoin "alphabet" as the encoding character set:
        <figure>
          <artwork>z2NEpo7TZRRrLZSi2U</artwork>
        </figure>
The first character (z) specifies the multibase encoding algorithm (entry
`base58btc` in the table below). The rest of the data specifies the value of the
output of the multibase encoding algorithm.
      </t>
    </section>
  </section>
</middle>

<back>
  <references>
    <name>Normative References</name>
    <reference anchor="RFC4648" target="https://www.rfc-editor.org/info/rfc4648">
      <front>
        <title>The Base16, Base32, and Base64 Data Encodings</title>
        <author fullname="S. Josefsson" initials="S." surname="Josefsson"/>
        <date month="October" year="2006"/>
      </front>
      <seriesInfo name="RFC" value="4648"/>
      <seriesInfo name="DOI" value="10.17487/RFC4648"/>
    </reference>
  </references>

  <section anchor="appendix-a" title="Security Considerations">
    <t>
There are a number of security considerations to take into account when
implementing or utilizing this specification.

TBD
    </t>
  </section>
  <section anchor="appendix-c" title="Test Values">

    <t>
The multibase examples are chosen to show different encoding algorithms and
different output lengths at play. The input test data for all of the
examples in this section is:
    </t>

    <figure>
      <artwork>Multibase is awesome! \o/</artwork>
    </figure>

    <section anchor="tv-base16upper" title="Hexadecimal upper-case encoding">
      <t>
        <figure>
          <artwork>
F4D756C74696261736520697320617765736F6D6521205C6F2F
          </artwork>
        </figure>
      </t>
    </section>

    <section anchor="tv-base32upper" title="Base-32 upper-case encoding, no padding">
      <t>
        <figure>
          <artwork>
BJV2WY5DJMJQXGZJANFZSAYLXMVZW63LFEEQFY3ZP
          </artwork>
        </figure>
      </t>
    </section>

    <section anchor="tv-base58btc" title="Base-58 Bitcoin encoding">
      <t>
        <figure>
          <artwork>
zYAjKoNbau5KiqmHPmSxYCvn66dA1vLmwbt
          </artwork>
        </figure>
      </t>
    </section>

    <section anchor="tv-base64pad" title="Base-64 with padding and MIME-encoding">
      <t>
        <figure>
          <artwork>
MTXVsdGliYXNlIGlzIGF3ZXNvbWUhIFxvLw==
          </artwork>
        </figure>
      </t>
    </section>

  </section>
  <section anchor="acknowledgements" title="Acknowledgements">
    <t>
The editors would like to thank the following individuals for feedback on and
implementations of the specification (in alphabetical order):
    </t>
  </section>
  <section anchor="appendix-d" title="IANA Considerations">
      <t>
The registry for this specification would be one of multiple registries in the
Multiformats registry group; registrations in this table would be keyed to
entries in the group's table on the UTF-8 column. See the <eref
target="http://www.caballerojuan.com/ccg-multiformats-spec/#appendix-c">IANA
Considerations</eref> section  of the 
<eref target="http://www.caballerojuan.com/ccg-multiformats-spec/">Multiformats
specification INFORMAL DRAFT</eref> for details on the governance thereof.
      </t>
    <section anchor="mb-registry" title="The Multibase Algorithms Registry">
      <t>
The following initial entries should be added to the Multibase Algorithms
Registry to be created and maintained at (the suggested URI)
        <eref target="http://www.iana.org/assignments/multibase-algorithms">http://www.iana.org/assignments/multibase-algorithms</eref>:
      </t>

      <texttable anchor="mb-registry-table" title="Multibase Algorithms Registry">
        <ttcol align="center">Algorithm</ttcol>
        <ttcol align="center">Identifier (codepoint)</ttcol>
        <ttcol align="center">Status</ttcol>
        <ttcol align="center">Specification</ttcol>

        <c>identity</c><c>NULL (0x00 in UTF-8)</c><c>reserved</c><c>8-bit binary (encoder and decoder keeps data unmodified)</c>
        <c>base2</c><c>0</c><c>final</c><c>binary (01010101)</c>
        <c>base8</c><c>7</c><c>final</c><c>octal</c>
        <c>base10</c><c>9</c><c>final</c><c>decimal</c>
        <c>base16</c><c>f</c><c>final</c><c>hexadecimal</c>
        <c>base16upper</c><c>F</c><c>final</c><c>hexadecimal</c>
        <c>base32hex</c><c>v</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> case-insensitive â€” no padding â€” highest char</c>
        <c>base32hexupper</c><c>V</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> case-insensitive â€” no padding â€” highest char</c>
        <c>base32hexpad</c><c>t</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> case-insensitive â€” with padding</c>
        <c>base32hexpadupper</c><c>T</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> case-insensitive â€” with padding</c>
        <c>base32</c><c>b</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> case-insensitive â€” no padding</c>
        <c>base32upper</c><c>B</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> case-insensitive â€” no padding</c>
        <c>base32pad</c><c>c</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> case-insensitive â€” with padding</c>
        <c>base32padupper</c><c>C</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> case-insensitive â€” with padding</c>
        <c>base32z</c><c>h</c><c>final</c><c>z-base-32 (used by Tahoe-LAFS)</c>
        <c>base36</c><c>k</c><c>final</c><c>base36 \[0-9a-z\] case-insensitive â€” no padding</c>
        <c>base36upper</c><c>K</c><c>final</c><c>base36 \[0-9a-z\] case-insensitive â€” no padding</c>
        <c>base58btc</c><c>z</c><c>final</c><c>base58 bitcoin</c>
        <c>base58flickr</c><c>Z</c><c>final</c><c>base58 flicker</c>
        <c>base64</c><c>m</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> no padding</c>
        <c>base64pad</c><c>M</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> with padding â€” MIME encoding</c>
        <c>base64url</c><c>u</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> no padding</c>
        <c>base64urlpad</c><c>U</c><c>final</c><c><xref target="RFC4648">RFC 4648</xref> with padding</c>
        <c>proquint</c><c>p</c><c>experimental</c><c>PRO-QUINT https://arxiv.org/html/0901.4016</c>
        <c>base256emoji</c><c>ðŸš€</c><c>experimental</c><c>base256 with custom alphabet using variable-sized-codepoints</c>
      </texttable>

      <t>
NOTE: The most up to date place for developers to find the definitive version of the table above is
<eref
target="https://github.com/multiformats/multibase/blob/master/multibase.csv">https://github.com/multiformats/multibase/blob/master/multibase.csv</eref>.
For purposes of this preview, the proposed update to this table can be found
here: <eref target="https://github.com/multiformats/multibase/blob/b9ca0426d9d1f8c4b7be6925e5b8be04cabe6ab9/multibase.csv">https://github.com/multiformats/multibase/blob/b9ca0426d9d1f8c4b7be6925e5b8be04cabe6ab9/multibase.csv</eref>.
      </t>
    </section>
  </section>
</back>
</rfc>
